-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Grammar.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Grammar.Abs
import Grammar.Lex

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)              }
  '!='             { PT _ (TS _ 2)              }
  '%'              { PT _ (TS _ 3)              }
  '&&'             { PT _ (TS _ 4)              }
  '\''             { PT _ (TS _ 5)              }
  '('              { PT _ (TS _ 6)              }
  ')'              { PT _ (TS _ 7)              }
  '*'              { PT _ (TS _ 8)              }
  '+'              { PT _ (TS _ 9)              }
  ','              { PT _ (TS _ 10)             }
  '-'              { PT _ (TS _ 11)             }
  '->'             { PT _ (TS _ 12)             }
  '/'              { PT _ (TS _ 13)             }
  ':'              { PT _ (TS _ 14)             }
  ';'              { PT _ (TS _ 15)             }
  '<'              { PT _ (TS _ 16)             }
  '<='             { PT _ (TS _ 17)             }
  '='              { PT _ (TS _ 18)             }
  '=='             { PT _ (TS _ 19)             }
  '>'              { PT _ (TS _ 20)             }
  '>='             { PT _ (TS _ 21)             }
  '['              { PT _ (TS _ 22)             }
  '[]'             { PT _ (TS _ 23)             }
  '\\/'            { PT _ (TS _ 24)             }
  ']'              { PT _ (TS _ 25)             }
  '_'              { PT _ (TS _ 26)             }
  'bool'           { PT _ (TS _ 27)             }
  'else'           { PT _ (TS _ 28)             }
  'if'             { PT _ (TS _ 29)             }
  'in'             { PT _ (TS _ 30)             }
  'int'            { PT _ (TS _ 31)             }
  'let'            { PT _ (TS _ 32)             }
  'match'          { PT _ (TS _ 33)             }
  'then'           { PT _ (TS _ 34)             }
  'type'           { PT _ (TS _ 35)             }
  'with'           { PT _ (TS _ 36)             }
  '|'              { PT _ (TS _ 37)             }
  L_Ident          { PT _ (TV $$)               }
  L_integ          { PT _ (TI $$)               }
  L_VarIdent       { PT _ (T_VarIdent $$)       }
  L_TypeIdent      { PT _ (T_TypeIdent $$)      }
  L_PolyIdentToken { PT _ (T_PolyIdentToken $$) }

%%

Ident :: { Grammar.Abs.Ident }
Ident  : L_Ident { Grammar.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

VarIdent :: { Grammar.Abs.VarIdent }
VarIdent  : L_VarIdent { Grammar.Abs.VarIdent $1 }

TypeIdent :: { Grammar.Abs.TypeIdent }
TypeIdent  : L_TypeIdent { Grammar.Abs.TypeIdent $1 }

PolyIdentToken :: { Grammar.Abs.PolyIdentToken }
PolyIdentToken  : L_PolyIdentToken { Grammar.Abs.PolyIdentToken $1 }

Program :: { Grammar.Abs.Program }
Program : ListTopDef { Grammar.Abs.Program $1 }

TopDef :: { Grammar.Abs.TopDef }
TopDef
  : VarDef ';' { Grammar.Abs.TopDefFn $1 }
  | TypeDef ';' { Grammar.Abs.TopDefType $1 }

TypeDef :: { Grammar.Abs.TypeDef }
TypeDef
  : 'type' TypeIdent '=' TypeDefOption { Grammar.Abs.TypeDef $2 $4 }

TypeDefOption :: { Grammar.Abs.TypeDefOption }
TypeDefOption
  : TypeIdent ListTypeH { Grammar.Abs.TypeDefOption $1 $2 }

TypeH :: { Grammar.Abs.TypeH }
TypeH
  : '(' TypeDefOption ')' { Grammar.Abs.TypeDefHCustType $2 }
  | Type { Grammar.Abs.TypeDefHType $1 }

VarDef :: { Grammar.Abs.VarDef }
VarDef : VarIdent '=' Expr { Grammar.Abs.VarDef $1 $3 }

ListTopDef :: { [Grammar.Abs.TopDef] }
ListTopDef : TopDef { (:[]) $1 } | TopDef ListTopDef { (:) $1 $2 }

Arg :: { Grammar.Abs.Arg }
Arg : VarIdent { Grammar.Abs.Arg $1 }

ListArg :: { [Grammar.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

ListTypeDefOption :: { [Grammar.Abs.TypeDefOption] }
ListTypeDefOption
  : {- empty -} { [] }
  | TypeDefOption { (:[]) $1 }
  | TypeDefOption '|' ListTypeDefOption { (:) $1 $3 }

ListTypeH :: { [Grammar.Abs.TypeH] }
ListTypeH : {- empty -} { [] } | TypeH ListTypeH { (:) $1 $2 }

Type :: { Grammar.Abs.Type }
Type
  : 'int' { Grammar.Abs.TypeInt }
  | 'bool' { Grammar.Abs.TypeBool }
  | '\'' PolyIdentToken { Grammar.Abs.TypePoly $2 }
  | ListTypeFnH { Grammar.Abs.TypeFn $1 }
  | '[' Type ']' { Grammar.Abs.TypeList $2 }
  | TypeIdent ListPolyIdent { Grammar.Abs.TypePolyFill $1 $2 }

TypeFnH :: { Grammar.Abs.TypeFnH }
TypeFnH : Type { Grammar.Abs.TypeFnH $1 }

PolyIdent :: { Grammar.Abs.PolyIdent }
PolyIdent : Type { Grammar.Abs.PolyIdent $1 }

ListPolyIdent :: { [Grammar.Abs.PolyIdent] }
ListPolyIdent
  : {- empty -} { [] } | PolyIdent ListPolyIdent { (:) $1 $2 }

ListTypeFnH :: { [Grammar.Abs.TypeFnH] }
ListTypeFnH
  : {- empty -} { [] }
  | TypeFnH { (:[]) $1 }
  | TypeFnH '->' ListTypeFnH { (:) $1 $3 }

BExpr4 :: { Grammar.Abs.BExpr }
BExpr4
  : VarIdent ListExpr { Grammar.Abs.BEApp $1 $2 }
  | '(' BExpr ')' { Grammar.Abs.BEBrackets $2 }
  | '(' BExpr ')' { $2 }

BExpr3 :: { Grammar.Abs.BExpr }
BExpr3 : '!' BExpr4 { Grammar.Abs.Not $2 } | BExpr4 { $1 }

BExpr2 :: { Grammar.Abs.BExpr }
BExpr2
  : Expr RelOp Expr { Grammar.Abs.BERel $1 $2 $3 } | BExpr3 { $1 }

BExpr1 :: { Grammar.Abs.BExpr }
BExpr1
  : BExpr2 '&&' BExpr1 { Grammar.Abs.BEAnd $1 $3 } | BExpr2 { $1 }

BExpr :: { Grammar.Abs.BExpr }
BExpr
  : BExpr1 '\\/' BExpr { Grammar.Abs.BEOr $1 $3 } | BExpr1 { $1 }

Expr3 :: { Grammar.Abs.Expr }
Expr3
  : '|' ListArg '|' Expr { Grammar.Abs.LambdaExpr $2 $4 }
  | Match { Grammar.Abs.MatchExpr $1 }
  | BExpr { Grammar.Abs.EBExpr $1 }
  | 'let' VarDef 'in' Expr { Grammar.Abs.ELetIn $2 $4 }
  | 'if' BExpr 'then' Expr 'else' Expr { Grammar.Abs.ECond $2 $4 $6 }
  | Ident ListExpr { Grammar.Abs.EApp $1 $2 }
  | Integer { Grammar.Abs.ELitInt $1 }
  | '[' ListLArg ']' { Grammar.Abs.ELitList $2 }
  | '(' Expr ')' { Grammar.Abs.EBrackets $2 }
  | '(' Expr ')' { $2 }

Expr2 :: { Grammar.Abs.Expr }
Expr2
  : '-' Expr3 { Grammar.Abs.Neg $2 }
  | Expr3 ':' Expr3 { Grammar.Abs.EListEx $1 $3 }
  | Expr3 { $1 }

Expr1 :: { Grammar.Abs.Expr }
Expr1
  : Expr1 MulOp Expr2 { Grammar.Abs.EMul $1 $2 $3 } | Expr2 { $1 }

Expr :: { Grammar.Abs.Expr }
Expr
  : Expr1 AddOp Expr { Grammar.Abs.EAdd $1 $2 $3 } | Expr1 { $1 }

LArg :: { Grammar.Abs.LArg }
LArg : Expr { Grammar.Abs.ListArg $1 }

ListLArg :: { [Grammar.Abs.LArg] }
ListLArg
  : {- empty -} { [] }
  | LArg { (:[]) $1 }
  | LArg ',' ListLArg { (:) $1 $3 }

ListExpr :: { [Grammar.Abs.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

Match :: { Grammar.Abs.Match }
Match
  : 'match' Expr 'with' ListMatchArm { Grammar.Abs.Match $2 $4 }

MatchArm :: { Grammar.Abs.MatchArm }
MatchArm
  : MatchArmSpecifier '->' Expr { Grammar.Abs.MatchArm $1 $3 }

MatchArmSpecifierHelper :: { Grammar.Abs.MatchArmSpecifierHelper }
MatchArmSpecifierHelper
  : MatchArmSpecifier { Grammar.Abs.MatchArmSpecifierH $1 }
  | VarIdent { Grammar.Abs.MatchArmSpecifierHI $1 }
  | '_' { Grammar.Abs.MatchArmSpecifierHU }

MatchArmSpecifier :: { Grammar.Abs.MatchArmSpecifier }
MatchArmSpecifier
  : '[]' { Grammar.Abs.MatchArmListEmpty }
  | '[' MatchArmSpecifierHelper ']' { Grammar.Abs.MatchArmListSingleton $2 }
  | MatchArmSpecifierHelper ':' MatchArmSpecifierHelper { Grammar.Abs.MatchArmListHeadTail $1 $3 }
  | TypeIdent ListMatchArmTypeHelper { Grammar.Abs.MatchArmType $1 $2 }

MatchArmTypeHelper :: { Grammar.Abs.MatchArmTypeHelper }
MatchArmTypeHelper
  : TypeIdent { Grammar.Abs.MatchArmTypeHelperIdent $1 }
  | '_' { Grammar.Abs.MatchArmTypeHelperFallback }
  | '(' MatchArmSpecifier ')' { Grammar.Abs.MatchArmTypeHelperType $2 }

ListMatchArm :: { [Grammar.Abs.MatchArm] }
ListMatchArm
  : {- empty -} { [] } | MatchArm ListMatchArm { (:) $1 $2 }

ListMatchArmTypeHelper :: { [Grammar.Abs.MatchArmTypeHelper] }
ListMatchArmTypeHelper
  : {- empty -} { [] }
  | MatchArmTypeHelper ListMatchArmTypeHelper { (:) $1 $2 }

AddOp :: { Grammar.Abs.AddOp }
AddOp : '+' { Grammar.Abs.Plus } | '-' { Grammar.Abs.Minus }

MulOp :: { Grammar.Abs.MulOp }
MulOp
  : '*' { Grammar.Abs.Times }
  | '/' { Grammar.Abs.Div }
  | '%' { Grammar.Abs.Mod }

RelOp :: { Grammar.Abs.RelOp }
RelOp
  : '<' { Grammar.Abs.LTH }
  | '<=' { Grammar.Abs.LE }
  | '>' { Grammar.Abs.GTH }
  | '>=' { Grammar.Abs.GE }
  | '==' { Grammar.Abs.EQU }
  | '!=' { Grammar.Abs.NE }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

