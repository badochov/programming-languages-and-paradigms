-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Grammar.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Grammar.Abs
import Grammar.Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)             }
  '!='             { PT _ (TS _ 2)             }
  '%'              { PT _ (TS _ 3)             }
  '&&'             { PT _ (TS _ 4)             }
  '\''             { PT _ (TS _ 5)             }
  '('              { PT _ (TS _ 6)             }
  ')'              { PT _ (TS _ 7)             }
  '*'              { PT _ (TS _ 8)             }
  '+'              { PT _ (TS _ 9)             }
  ','              { PT _ (TS _ 10)            }
  '-'              { PT _ (TS _ 11)            }
  '->'             { PT _ (TS _ 12)            }
  '/'              { PT _ (TS _ 13)            }
  ':'              { PT _ (TS _ 14)            }
  ';'              { PT _ (TS _ 15)            }
  '<'              { PT _ (TS _ 16)            }
  '<='             { PT _ (TS _ 17)            }
  '='              { PT _ (TS _ 18)            }
  '=='             { PT _ (TS _ 19)            }
  '>'              { PT _ (TS _ 20)            }
  '>='             { PT _ (TS _ 21)            }
  '['              { PT _ (TS _ 22)            }
  '[]'             { PT _ (TS _ 23)            }
  '\\/'            { PT _ (TS _ 24)            }
  ']'              { PT _ (TS _ 25)            }
  '_'              { PT _ (TS _ 26)            }
  'bool'           { PT _ (TS _ 27)            }
  'else'           { PT _ (TS _ 28)            }
  'if'             { PT _ (TS _ 29)            }
  'in'             { PT _ (TS _ 30)            }
  'int'            { PT _ (TS _ 31)            }
  'let'            { PT _ (TS _ 32)            }
  'match'          { PT _ (TS _ 33)            }
  'then'           { PT _ (TS _ 34)            }
  'type'           { PT _ (TS _ 35)            }
  'with'           { PT _ (TS _ 36)            }
  '|'              { PT _ (TS _ 37)            }
  L_integ          { PT _ (TI _)               }
  L_VarName        { PT _ (T_VarName _)        }
  L_TypeName       { PT _ (T_TypeName _)       }
  L_PolyIdentToken { PT _ (T_PolyIdentToken _) }

%%

Integer :: { (Grammar.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

VarName :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.VarName) }
VarName  : L_VarName { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.VarName (tokenText $1)) }

TypeName :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TypeName) }
TypeName  : L_TypeName { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeName (tokenText $1)) }

PolyIdentToken :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.PolyIdentToken) }
PolyIdentToken  : L_PolyIdentToken { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.PolyIdentToken (tokenText $1)) }

Program :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Program) }
Program
  : ListTopDef { (fst $1, Grammar.Abs.Program (fst $1) (snd $1)) }

TopDef :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TopDef) }
TopDef
  : VarDef ';' { (fst $1, Grammar.Abs.TopDefFn (fst $1) (snd $1)) }
  | TypeDef ';' { (fst $1, Grammar.Abs.TopDefType (fst $1) (snd $1)) }

TypeDef :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TypeDef) }
TypeDef
  : 'type' TypeName '=' TypeDefOption { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeDef (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

TypeDefOption :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TypeDefOption) }
TypeDefOption
  : TypeName ListTypeH { (fst $1, Grammar.Abs.TypeDefOption (fst $1) (snd $1) (snd $2)) }

TypeH :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TypeH) }
TypeH
  : '(' TypeDefOption ')' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeDefHCustType (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Type { (fst $1, Grammar.Abs.TypeDefHType (fst $1) (snd $1)) }

VarDef :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.VarDef) }
VarDef
  : VarName '=' Expr { (fst $1, Grammar.Abs.VarDef (fst $1) (snd $1) (snd $3)) }

ListTopDef :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.TopDef]) }
ListTopDef
  : TopDef { (fst $1, (:[]) (snd $1)) }
  | TopDef ListTopDef { (fst $1, (:) (snd $1) (snd $2)) }

Arg :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Arg) }
Arg : VarName { (fst $1, Grammar.Abs.Arg (fst $1) (snd $1)) }

ListArg :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.Arg]) }
ListArg
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | Arg ListArg { (fst $1, (:) (snd $1) (snd $2)) }

ListTypeDefOption :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.TypeDefOption]) }
ListTypeDefOption
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | TypeDefOption { (fst $1, (:[]) (snd $1)) }
  | TypeDefOption '|' ListTypeDefOption { (fst $1, (:) (snd $1) (snd $3)) }

ListTypeH :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.TypeH]) }
ListTypeH
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | TypeH ListTypeH { (fst $1, (:) (snd $1) (snd $2)) }

Type :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Type) }
Type
  : 'int' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeInt (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'bool' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeBool (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '\'' PolyIdentToken { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypePoly (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | ListTypeFnH { (fst $1, Grammar.Abs.TypeFn (fst $1) (snd $1)) }
  | '[' Type ']' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.TypeList (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | TypeName ListPolyIdent { (fst $1, Grammar.Abs.TypePolyFill (fst $1) (snd $1) (snd $2)) }

TypeFnH :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.TypeFnH) }
TypeFnH : Type { (fst $1, Grammar.Abs.TypeFnH (fst $1) (snd $1)) }

PolyIdent :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.PolyIdent) }
PolyIdent
  : Type { (fst $1, Grammar.Abs.PolyIdent (fst $1) (snd $1)) }

ListPolyIdent :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.PolyIdent]) }
ListPolyIdent
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | PolyIdent ListPolyIdent { (fst $1, (:) (snd $1) (snd $2)) }

ListTypeFnH :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.TypeFnH]) }
ListTypeFnH
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | TypeFnH { (fst $1, (:[]) (snd $1)) }
  | TypeFnH '->' ListTypeFnH { (fst $1, (:) (snd $1) (snd $3)) }

Expr6 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr6
  : '|' ListArg '|' Expr { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.LambdaExpr (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Match { (fst $1, Grammar.Abs.MatchExpr (fst $1) (snd $1)) }
  | 'let' VarDef 'in' Expr { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.ELetIn (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | 'if' Expr 'then' Expr 'else' Expr { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.ECond (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | FnOrTypeIdent ListExpr { (fst $1, Grammar.Abs.EApp (fst $1) (snd $1) (snd $2)) }
  | Integer { (fst $1, Grammar.Abs.ELitInt (fst $1) (snd $1)) }
  | '[' ListLArg ']' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.ELitList (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Expr ')' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.EBrackets (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Expr ')' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Expr5 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr5
  : '-' Expr6 { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Neg (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '!' Expr6 { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Not (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr6 ':' Expr6 { (fst $1, Grammar.Abs.EListEx (fst $1) (snd $1) (snd $3)) }
  | Expr6 { (fst $1, (snd $1)) }

Expr4 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr4
  : Expr4 MulOp Expr5 { (fst $1, Grammar.Abs.EMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr5 { (fst $1, (snd $1)) }

Expr3 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr3
  : Expr3 AddOp Expr4 { (fst $1, Grammar.Abs.EAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr4 { (fst $1, (snd $1)) }

Expr2 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr2
  : Expr2 RelOp Expr3 { (fst $1, Grammar.Abs.ERel (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

Expr1 :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr1
  : Expr2 '&&' Expr1 { (fst $1, Grammar.Abs.EAnd (fst $1) (snd $1) (snd $3)) }
  | Expr2 { (fst $1, (snd $1)) }

Expr :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Expr) }
Expr
  : Expr1 '\\/' Expr { (fst $1, Grammar.Abs.EOr (fst $1) (snd $1) (snd $3)) }
  | Expr1 { (fst $1, (snd $1)) }

LArg :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.LArg) }
LArg : Expr { (fst $1, Grammar.Abs.ListArg (fst $1) (snd $1)) }

FnOrTypeIdent :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.FnOrTypeIdent) }
FnOrTypeIdent
  : VarName { (fst $1, Grammar.Abs.VarIdent (fst $1) (snd $1)) }
  | TypeName { (fst $1, Grammar.Abs.TypeIdent (fst $1) (snd $1)) }

ListLArg :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.LArg]) }
ListLArg
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | LArg { (fst $1, (:[]) (snd $1)) }
  | LArg ',' ListLArg { (fst $1, (:) (snd $1) (snd $3)) }

ListExpr :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.Expr]) }
ListExpr
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | Expr ListExpr { (fst $1, (:) (snd $1) (snd $2)) }

Match :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.Match) }
Match
  : 'match' Expr 'with' ListMatchArm { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Match (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

MatchArm :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.MatchArm) }
MatchArm
  : MatchArmSpecifier '->' Expr { (fst $1, Grammar.Abs.MatchArm (fst $1) (snd $1) (snd $3)) }

MatchArmSpecifierHelper :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.MatchArmSpecifierHelper) }
MatchArmSpecifierHelper
  : MatchArmSpecifier { (fst $1, Grammar.Abs.MatchArmSpecifierH (fst $1) (snd $1)) }
  | VarName { (fst $1, Grammar.Abs.MatchArmSpecifierHI (fst $1) (snd $1)) }
  | '_' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.MatchArmSpecifierHU (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }

MatchArmSpecifier :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.MatchArmSpecifier) }
MatchArmSpecifier
  : '[]' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.MatchArmListEmpty (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '[' MatchArmSpecifierHelper ']' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.MatchArmListSingleton (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | MatchArmSpecifierHelper ':' MatchArmSpecifierHelper { (fst $1, Grammar.Abs.MatchArmListHeadTail (fst $1) (snd $1) (snd $3)) }
  | TypeName ListMatchArmTypeHelper { (fst $1, Grammar.Abs.MatchArmType (fst $1) (snd $1) (snd $2)) }

MatchArmTypeHelper :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.MatchArmTypeHelper) }
MatchArmTypeHelper
  : TypeName { (fst $1, Grammar.Abs.MatchArmTypeHelperIdent (fst $1) (snd $1)) }
  | '_' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.MatchArmTypeHelperFallback (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '(' MatchArmSpecifier ')' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.MatchArmTypeHelperType (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListMatchArm :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.MatchArm]) }
ListMatchArm
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | MatchArm ListMatchArm { (fst $1, (:) (snd $1) (snd $2)) }

ListMatchArmTypeHelper :: { (Grammar.Abs.BNFC'Position, [Grammar.Abs.MatchArmTypeHelper]) }
ListMatchArmTypeHelper
  : {- empty -} { (Grammar.Abs.BNFC'NoPosition, []) }
  | MatchArmTypeHelper ListMatchArmTypeHelper { (fst $1, (:) (snd $1) (snd $2)) }

AddOp :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.AddOp) }
AddOp
  : '+' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Plus (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Minus (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.MulOp) }
MulOp
  : '*' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Times (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Div (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.Mod (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }

RelOp :: { (Grammar.Abs.BNFC'Position, Grammar.Abs.RelOp) }
RelOp
  : '<' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.LTH (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.LE (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.GTH (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.GE (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '==' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.EQU (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1), Grammar.Abs.NE (uncurry Grammar.Abs.BNFC'Position (tokenLineCol $1))) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Grammar.Abs.Program
pProgram = fmap snd . pProgram_internal
}

